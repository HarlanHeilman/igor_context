# Particle Analysis

Chapter III-11 — Image Processing
III-375
Note that we used /H={330,50}. The apparent flip of the limits is allowed in the case of hue values to cover 
the single range from hue angle 330 degrees to hue angle 50 degrees.
There are two additional approaches for color segmentation that should be mentioned here. You can use 
ImageTransform matchPlanes operation to segment an image for pixels that satisfy prescribed value ranges 
in all planes. This operation has the advantage that it can be applied to images in any color space. Another 
segmentation operation is ImageTransform selectColor which is based on RGB color space and a user pro-
vided tolerance value. The same concept can be applied with ImageSeedFill to get the effect of a “magic 
wand” selection.
Particle Analysis
Typical particle analysis consists of three steps. First you need to preprocess the image. This may include 
noise removal or reduction, possible background adjustments (see ImageRemoveBackground operation 
on page V-403) and thresholding. Once you obtain a binary image, your second step is to invoke the Imag-
eAnalyzeParticles operation (see page V-363). The third and final step is making some sense of all the data 
produced by the ImageAnalyzeParticles operation or “post-processing”.
Issues related to the preprocessing have been discussed elsewhere in this chapter. We will assume that we 
are starting with a preprocessed, clean, binary image which contains some particles.
NewImage root:images:blobs
// display the original image
// Step 1:create binary image.
// Note the /I flag to invert the output wave so that particles are marked by 
zero.
ImageThreshold/I/Q/M=1 root:images:blobs
// Note the /I flag!!
// Step 2:Here we are invoking the operation in quiet mode, specifying particles
// of size equal or greater than 2 pixels. We are also asking for particles 
moment
// Information, boundary waves and a particle masking wave.
ImageAnalyzeParticles /Q/A=2/E/W/M=2 stats M_ImageThresh
// Step 3:post processing choices
// Display the detected boundaries on top of the particles
AppendToGraph/T W_BoundaryY vs W_BoundaryX
// If you browse the numerical data:
Edit W_SpotX,W_SpotY,W_circularity,W_rectangularity,W_ImageObjPerimeter
AppendToTable W_xmin,W_xmax,W_ymin,W_ymax,M_Moments,M_RawMoments
Note that particles that intersect the boundary of the image may give rise to inaccuracies in particle statis-
tics. It is therefore useful sometimes to remove these particles before performing the analysis.
The raw values generated by ImageAnalyzeParticles operation can be used for further processing.
The following example illustrates slightly different pre and post-processing.
NewImage screws
// Here we have a synthetic background so the conversion to binary is easy.
screws=screws==163 ? 255:0
ImageMorphology /O/I=2/E=1 binarydilation screws
ImageMorphology /O/I=2/E=1 erosion screws
// Now the particle analysis operation with the option to fill the holes.
ImageAnalyzeParticles/E/W/Q/M=3/A=5/F stats, screws
NewImage root:images:screws
AutoPositionWindow/E $WinName(0,1)
// Show the detected boundaries.
AppendToGraph/T W_BoundaryY vs W_BoundaryX
AppendToGraph/T W_SpotY vs W_SpotX
Duplicate/O w_spotx w_index

Chapter III-11 — Image Processing
III-376
w_index=p
ModifyGraph mode(W_SpotY)=3
ModifyGraph textMarker(W_SpotY)={w_index,"default",1,0,5,0.00,0.00}
ModifyGraph msize(W_SpotY)=6
Now for some shape classification in which we plot particle area versus perimeter:
Display/W=(23.4,299.6,297,511.4) W_ImageObjArea vs W_ImageObjPerimeter
ModifyGraph 
mode=3,textMarker(W_ImageObjArea)={w_index,"default",0,0,5,0.00,0.00}
ModifyGraph msize=6
The classification diagram we just created uses two parameters (area and perimeter) that are very sensitive 
to image noise. We can see that there are two basic classes that can be associated with the roundness of the 
boundaries but it is difficult to accept the classification of particle 9.
In the following we compute another classification based on the eccentricity of the objects:
Make/O/N=(DimSize(M_Moments,0)) ecc
ecc=sqrt(1-M_Moments[p][3]^2/M_Moments[p][2]^2)
Display /W=(23.4,299.6,297,511.4) ecc
ModifyGraph mode=3,textMarker(ecc)={w_index,"default",0,0,5,0.00,0.00}
ModifyGraph msize=6
